import torch
import torch.nn.functional as F
import networkx as nx
from typing import Iterable, Dict


def build_spatiotemporal_graph(
    segment_features: Iterable[Dict],
    temporal_weight: float = 1.0,
):
    """根据片段特征构建时空图。

    Args:
        segment_features: 包含 ``image_features`` 键的片段信息迭代器。
        temporal_weight: 时间边的权重。

    Returns:
        networkx.Graph: 构建完成的时空图。
    """

    segment_features = list(segment_features)
    if not segment_features:
        raise ValueError("segment_features is empty")

    features = torch.cat([d["image_features"] for d in segment_features], dim=0)
    num_segments = len(segment_features)

    G = nx.Graph()
    for idx, info in enumerate(segment_features):
        node_attr = dict(info)
        node_attr["feature"] = info["image_features"].squeeze(0)
        node_attr.pop("image_features", None)
        G.add_node(idx, **node_attr)

    for i in range(num_segments - 1):
        G.add_edge(i, i + 1, type="temporal", weight=temporal_weight)

    sim_matrix = F.cosine_similarity(
        features.unsqueeze(1),
        features.unsqueeze(0),
        dim=-1,
    )

    for i in range(num_segments):
        for j in range(num_segments):
            if i == j:
                continue
            if abs(i - j) == 1:
                continue
            sim = float(sim_matrix[i, j].item())
            G.add_edge(i, j, type="spatial", weight=sim)

    return G


if __name__ == "__main__":
    import argparse
    import pickle

    parser = argparse.ArgumentParser(description="Build spatio-temporal graph from features")
    parser.add_argument("features_pt", help="Path to the .pt file generated by chunk_embedding.py")
    parser.add_argument("output", help="Where to save the pickled graph")
    parser.add_argument("--temporal-weight", type=float, default=1.0, dest="temporal_weight")

    args = parser.parse_args()

    data = torch.load(args.features_pt)
    graph = build_spatiotemporal_graph(data, temporal_weight=args.temporal_weight)

    with open(args.output, "wb") as f:
        pickle.dump(graph, f)

    print(f"Graph saved to {args.output} ({graph.number_of_nodes()} nodes, {graph.number_of_edges()} edges)")
